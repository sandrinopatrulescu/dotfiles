# vim: set filetype=sh : " treat this file as a shell script

. "$DOTS"/linux/functions.sh

# Notes:
#   1. add comments inside the function, for easier portability
#   2. functions specifications:
#       1. specifications should have 39 starting and ending #'s followed immediately by newline character (if you change this, then make sure to update how() accordingly)
#       2. 
#   3. use returns codes in the range 64 - 113 (https://tldp.org/LDP/abs/html/exitcodes.html)
# 

# Utility 01: find aliases inside the functions file:
# clear; for alias_name in $(aliases | sed '/usage/d;s@alias @@;/^[^A-Za-z]/d'); do echo ${alias_name}; \grep -wn --color "${alias_name}" < ~/.functions; done



    ### Temporary ### {{{
clone-webelopers() {
    local project_name="SE-925-2-Webelopers"
    # cd $UNIPATH/S4.SE/labs || return 1
    [ -d "$project_name" ] && { echo "Directory $project_name already exists. No action will be performed"; return 1; }

    echo "Connect to git:"
    sau || { echo "FAILED to connect to the GitHub account"; return 1; }

    g clone git@github.com:915-Negrau-Mircea/SE-925-2-Webelopers.git && echo "Successfuly cloned the repository" || { echo "FAILED to clone the repository"; return 1; }
    echo
    cd "$project_name" && echo "Moved to project directory" || echo "Failed to move to project directory"

    echo
    git update-index --assume-unchanged back-end/Org.Webelopers.API/appsettings.json && echo "Performed: git update-index --assume-unchanged back-end/Org.Webelopers.API/appsettings.json" || { echo "git update-index --assume-unchanged on appsettings.json FAILED"; return 1; } 

    echo
    echo 'TO DO: Replace the content of "DefaultConnection" from the key "ConnectionStrings" inside appsettings.json with:'
    sqlconnectionstring
    echo
    echo "TO DO: mousepad back-end/Org.Webelopers.API/appsettings.json"

    echo
    echo "TO DO: After that, perform gs (git status) to test if it succeeded."
}

timezip() {
    zip -r "${1}_$(date +%Y-%m-%d_%H-%M-%S).zip" "${1}" 
}

contact() {
    cat $DOTS_SECRETS/contact.txt
}

eject-disk() {
    # usage: eject-disk <disk>
    # ex: eject-disk /dev/sdb
    sudo umount $1 &&
        eject -v $1 &&
        udiskctl power-off -b $1
}

symlink-jetbrains() {
    local oldpwd="$PWD"

    cd ~/.local/share &&
        sudo rsync -avP ./JetBrains /f/ &&
        rm -r ./JetBrains &&
        ln -s /f/JetBrains

    cd "$oldpwd"
}

earthrise-reminder-trello() {
    local names=("Alice" "Andreea" "Daniela" "Florin" "Irina")

    for i in ${!names[@]}; do
        names[i]=", ${names[i]}"
        #echo $i ${names[i]}
    done

    names+=("")

    for name in "${names[@]}"; do
        echo "Bună$name!"
        cat <<'EOF'
Se spune că "eșecul este cheia succesului", dar eu cred că introspecția asupra acelui eșec este adevărata cheie. Pentru a ne ajuta la introspecție și a ne motiva, avem un tool cu care să ținem evidența contribuților noastre. De asemenea, ne ajută să aratăm organizatorilor proiectului că suntem on the right track. So, kind reminder: let TRELLO know you're making history!
EOF
        echo
    done
}

concat-mp4() { # merge mp4 files using ffmpeg
    # usage:a concat-mp4 FILES...
    # source: https://stackoverflow.com/questions/7333232/how-to-concatenate-two-mp4-files-using-ffmpeg 

    local filename="concat-mp4-list_$(date +%Y-%m-%d_%H-%M-%S)"

    for file in "$@"; do
        echo "file '$file'" >> "$filename.txt"
    done

    ffmpeg -f concat -safe 0 -i "$filename.txt" -c copy "$filename.mp4"
}


screen-brightness() {
  [ "$#" -eq 0 ] && {
      xrandr --verbose | grep -i brightness;
      return
  }
  pkill -9 redshift
    # source: linux cant change display brightness https://www.debugpoint.com/F2-ways-fix-laptop-brightness-problem-ubuntu-linux/
  xrandr --output eDP-1-1 --brightness $1
}

mint_setup_autostart() {
  for file in "$DOTS"/mint/autostart/*; do
    if [ -L ~/.config/autostart/"$(basename "$file")" ]; then
      if [ "$(readlink ~/.config/autostart/"$(basename "$file")")" = "$file" ]; then
        continue; # already linked
      else
        echo "Already linked to another file: $file";
        continue;
      fi
    else
      # link the file
      ln -vs "$file" ~/.config/autostart;
    fi
  done
}

mint_setup_services() {
  for file in "$DOTS"/mint/service/*; do
    echo "$file";
    [ ! -L /etc/systemd/system/"$(basename "$file")" ] && sudo ln -vs "$file" /etc/systemd/system/;
    sudo systemctl enable "$(basename "$file")";
    sudo systemctl start "$(basename "$file")";
  done
  echo "Reboot to take effect"
}


try_git_clone() {
    # usage: try_git_clone <mode (ssh/https)> <user> <repo name>
    [ $# -eq 3 ] || { echo "usage: $FUNCNAME <mode (ssh/https)> <user> <repo name>" && return 1; }
    local url="$2/$3"
    case $1 in
    ssh)
        url="git@github.com:${url}.git";;
    https)
        url="https://github.com/${url}";;
    *)
        echo "Invalid mode: $1"; return 1;;
    esac
    sudo rm -r "$3"
    echo "URL: $url"
    git clone "${url}"
}

startonw() # start on workspace
{
    local workspaceIdx="$1"
    local waitTime="$2"
    local windowName="$3"
    shift 3

    ("$@" > /dev/null 2>&1 &)

    local pid=$([ -n "$windowName" ] && wmctrl -lp | \grep "$windowName" | awk '{print $3}' | tail -1)
    while [ -z "$pid" ]; do
        if [ -n "$windowName" ]; then
            pid=$(wmctrl -lp | \grep "$windowName" | awk '{print $3}' | tail -1)
        else
            for pid_candidate in $(pidof "$@" | tr ' ' '\n' | sort -n | head -1; ps wup "$(pgrep -f "$*")" | tail -1 | awk '{print $2}'); do
                [ -n "$pid_candidate" ] && {
                    pid="$pid_candidate"
                    break 2
                }
            done
        fi
        sleep 1
    done

    local windowNumber=$(wmctrl -lp | grep "$pid" | awk '{print $1}')
    while [ -z "$windowNumber" ]; do
        sleep 0.5
        windowNumber=$(wmctrl -lp | grep "$pid" | awk '{print $1}')
    done

    sleep "$waitTime" && wmctrl -t $workspaceIdx -i -r $windowNumber
}

btop() { # bachelor thesis open
    # test run w/: "src; set -x; btop; set +x"

    # https://askubuntu.com/questions/41093/is-there-a-command-to-go-a-specific-workspace

    startonw 1 1.0 "" /usr/share/code/code
    startonw 1 0.0 "Udemy-Complete.guide.to.building.an.app.with.Net.Core.and.React - Thunar" thunar "/e/torrents-downloads/Udemy-Complete.guide.to.building.an.app.with.Net.Core.and.React/"

    startonw 4 0.5 "" /opt/google/chrome-beta/chrome

    startonw 2 0.0 "Reactivities – /mnt/e/Scratch/bt/neil-dotnet-react/Reactivities/README.md" /bin/bash /home/kamui/.local/share/JetBrains/Toolbox/scripts/rider
    startonw 2 0.0 "Udemy-Complete.guide.to.building.an.app.with.Net.Core.and.React - Thunar" thunar "/e/torrents-downloads/Udemy-Complete.guide.to.building.an.app.with.Net.Core.and.React/"

    wmctrl -s 1
}

btcl() { # bachelor thesis close
    for window_id in $(wmctrl -l -x | awk -F' ' '$2 ~ /^[124]$/ {print $1}'); do
        echo "Closing window $window_id: $(xprop -id "$window_id" WM_NAME)"
        wmctrl -ic "$window_id"
    done
    wmctrl -s 2
}
# }}}

    ### Uncategorized ### {{{

beep() { # play beep sound [<n times>]
    # usage: $FUNCNAME [<count>]

    # find first phone-incoming-call.* in /usr/share/sounds
    declare phoneIncomingCallFiles="$(find /usr/share/sounds/ -iname "phone-incoming-call.*")"

    # if there are multiple files, choose the one not in the freedesktop directory, otherwise choose that one, otherwise choose the first one, otherwise fail
    declare phoneIncomingCallFile="$(echo "${phoneIncomingCallFiles}" | grep -v "freedesktop" | head -n 1)"
    [ -z "${phoneIncomingCallFile}" ] && phoneIncomingCallFile="$(echo "${phoneIncomingCallFiles}" | grep "freedesktop" | head -n 1)"
    [ -z "${phoneIncomingCallFile}" ] && phoneIncomingCallFile="$(echo "${phoneIncomingCallFiles}" | head -n 1)"
    [ -z "${phoneIncomingCallFile}" ] && { echo "No phone-incoming-call.* file found in /usr/share/sounds/"; return 1; }


    repeat "${1:-1}" paplay "${phoneIncomingCallFile}"
    # source: https://www.newbiescorner.com/2017/12/06/beep-command-alert-when-the-task-is-finished/ 
}

# [1] get named variabled (usage: get <VAR_NAME>)
getvar() { # print the value of a variable
    echo "${!1}"
}



# [1] add a new directory to the PATH variable
# Note: I use this inside the env file, it doesn't seem to be working
# in terminal
append-path() { # add something to $PATH
    [ -d $1 ] && ! grep -q $1 <<< "$PATH" && export PATH=$PATH:$1 || true
}



# [1]
clc() { # calculator
    echo "$*" | bc -l 
}


calc() { # calculator
    clc "$@"
}


# [1]
mkcd() { # mkdir -p + cd
    mkdir -pv "$@" && cd "$@"
}

e() { # evince
    (evince "$@" &)
}

m() { # mousepad
    (mousepad "$@" &)
}

t() { # thunar
    (thunar "$@" &)
}

cscr() { #  C Sharp Compile & Run
    local file
    file=$1; mcs $file -r:System.Windows.Forms.dll -r:System.Data && mono $(echo "$file" | sed 's@.cs@.exe@')
}

mcs2() { # mono c sharp compiler
    local projectName
    projectName="$(basename $PWD)"; mcs -out:bin/Debug/"${projectName}".exe -r:System.Data -r:System.Windows.Forms.dll -r:System.Drawing $(find src/ -iname "*.cs") && (cd bin/Debug/; mono "${projectName}".exe) # https://stackoverflow.com/questions/1794127/how-do-i-compile-all-files-in-a-directory-with-mono/ 
}


pathwin2wsl() { # convert windows path to wsl (unix) path; NOTE: the path needs to be quoted (for some reason or another)
	# remove the :
	# convert drive letter to lowercase
	# replace backslashes with forward slashes; source: https://stackoverflow.com/questions/52256461/convert-first-letter-to-lowercase-using-sed
	# prepend /mnt/ to the path
	echo "$1" | sed -E 's@:@@;s@^.@\L&@;s@\\@/@g;s@^@/mnt/@'
}

pathwsl2win() { # convert wsl (unix) path to windows path
	# replace forwardslashes with backslashes
    # change to windows drive letter: s@^\\mnt\\([a-z])\\@\1:\\@;
    # turn letter to upper case: s@^[a-z]@\U&@; # https://phpfog.com/how-to-uppercase-lowercase-text-with-sed/
	# prepend \\wsl$\Ubuntu
	readlink -f "$1" | sed -E 's@/@\\@g;s@^\\mnt\\([a-z])\\@\1:\\@;s@^[a-z]@\U&@;s@^\\@\\\\wsl\$\\Ubuntu\\@'
}

winop() { # WINdows OPen - open files and directories using the Windows dialog
	echo -n "Path in WSL: "; readlink -f "$1"
	echo -n "Path in Windows: "; echo "$(pathwsl2win "$1")"
	explorer.exe "$(pathwsl2win "$1")"
}


remove-package() { # taken from the Evernote/Linux - Completely remove .deb package
    sudo apt purge "${1}"
    sudo apt --purge autoremove
    sudo apt clean
}


pd() { # go to Parent Dir or go to [n]th parent dir
    local final_destination="."
    # usage:
    #   pd -p [<n>] # just print where it would lead
    #   pd # go to parent dir
    #   pd <n> # go to n-th parent dir
    local print_only=0

    [ "$1" == "-p" ] && { print_only=1; shift; }

    [ $# -eq 1 ] && steps="$1" || steps=1

    for step in $(seq $steps); do
        final_destination="../${final_destination}"
    done
  
    [ $print_only -eq 1 ] && readlink -f "$final_destination" || cd "$final_destination"
}

cpp-generate-exception-class() {
    [ $# -ne 2 ] && {
        echo "usage: $FUNCNAME <exception class name> <base name>"
    }
    cat <<EOF
class $1: public $2 {
public:
    explicit $1(const std::string& message): $2(message) { name = Meta::getClassName(this); }
};
EOF
}

join1() { # join arguments/strings by a character
    local IFS="$1"
    shift
    echo "$*"
}

sshconnect() { ## ssh connect
    # USAGE: sc PORT USER ADDR
    # ssh -p port user@addr
    ssh -vp $1 "$2@$3"
}


printSemesterWeek() { # prints a message with the number of the semester week
	# usage: [<WEEK_NUMBER>] [SEMESTER]
	# 		WEEK_NUMBER - the week number of the year, in range [1,52], for testing
	#		SEMESTER={1|2} - simulate a semster 
	#		all other arguments are ignored
	#		OBS: 
	#			- there is 1 (kind of) unhandled case: the 2nd semester is set, but is not yet started.
	#				The problem is that is says "x more weeks to go!", although the 1st semester is still ON-GOING
	# testing:
	# 		for x in {1..52}; do echo -n "$x "; printSemesterWeek $x 1; done # 1st semester
	# 		for x in {1..52}; do echo -n "$x "; printSemesterWeek $x 2; done # 2nd semester


	# change at the start of the semester
	local LAST_WEEK_BEFORE_SEMESTER_START=40
	local FIRST_VACATION_WEEK=1
	local LAST_VACATION_WEEK=2
	local VACATION_TYPE="Christmass" # Easter / Christmass
	
	# unlikely to change
	local SEMESTER_SIZE=14
	local SUMMER_SIZE=11 # no. of summer vacation weeks 
	
	# sample for when SEMESTER is provided
	[ $# -ge 2 ] && {
		if [ "$2" -eq 1 ]; then
				local LAST_WEEK_BEFORE_SEMESTER_START=38
				local FIRST_VACATION_WEEK=51
				local LAST_VACATION_WEEK=52
				local VACATION_TYPE="Christmass" # Easter / Christmass
		elif [ "$2" -eq 2 ]; then
			local LAST_WEEK_BEFORE_SEMESTER_START=7
			local FIRST_VACATION_WEEK=17
			local LAST_VACATION_WEEK=17
			local VACATION_TYPE="Easter" # Easter / Christmass
		fi
	}

	local VACATION_SIZE=$((LAST_VACATION_WEEK - FIRST_VACATION_WEEK + 1))
	local LAST_SEMESTER_WEEK=$((LAST_WEEK_BEFORE_SEMESTER_START + VACATION_SIZE + 14)) # +52 in case of 1st semester

	[ $# -ge 1 ] && currentWeek=$1 || currentWeek=$(date +%V)
    #((currentWeek += 1)) # TODO: increased week number by 1 for 2022 bc. 
                # it seems that 'date' doesn't consider the week that contains
                # January 1st as the 1st week of the year.
                # EDIT: the reason is the ISO leap week


	#if [ 1 -le $currentWeek -a $currentWeek -le $((LAST_SEMESTER_WEEK + 5 - 52)) ]
	#if [ $LAST_SEMESTER_WEEK -gt 52 -a $currentWeek -lt $LAST_WEEK_BEFORE_SEMESTER_START ]
	if [ $LAST_SEMESTER_WEEK -gt 52 -a $currentWeek -lt $((LAST_WEEK_BEFORE_SEMESTER_START + 1 - SUMMER_SIZE)) ] # 2nd comparision fixes the case when the first semester is already set during the vacation
	then
		((currentWeek += 52))
	fi

	if [ $currentWeek -le $LAST_WEEK_BEFORE_SEMESTER_START ] #|| [ $currentWeek -gt $((LAST_SEMESTER_WEEK + 5 )) -a $LAST_SEMESTER_WEEK -gt 52  ]
	then
		echo "$((LAST_WEEK_BEFORE_SEMESTER_START - currentWeek + 1)) more weeks to go!"
	elif [ $currentWeek -lt $FIRST_VACATION_WEEK ]
	then
		echo "Week $((currentWeek - LAST_WEEK_BEFORE_SEMESTER_START))/$SEMESTER_SIZE" 
	elif [ $currentWeek -le $LAST_VACATION_WEEK ]
	then
		echo "$VACATION_TYPE $((currentWeek - FIRST_VACATION_WEEK + 1))/$VACATION_SIZE"
	elif [ $currentWeek -le $LAST_SEMESTER_WEEK ]
	then
		echo "Week $((currentWeek - LAST_WEEK_BEFORE_SEMESTER_START - VACATION_SIZE))/$SEMESTER_SIZE" 
	elif [ $currentWeek -le $((LAST_SEMESTER_WEEK + 3)) ]
	then
		echo "E $((currentWeek - LAST_SEMESTER_WEEK))/3"
	elif [ $currentWeek -eq $((LAST_SEMESTER_WEEK + 4)) ]
	then
		echo "V 1/1"
	elif [ $currentWeek -eq $((LAST_SEMESTER_WEEK + 5)) ]
	then
		echo "R 1/1"
	else
		if [ $LAST_SEMESTER_WEEK -gt 52 ]; then
			echo "You are now in the 2nd semester. Update the variables"
		else
			echo "You are now in vacation. Update the variables or comment out the function call"
		fi		
	# echo "Update the semester variables or comment out the function call."
	fi
}

cat << EOF > /dev/null
>| ~/testPrintSemesterWeek.sh
echo '#!/bin/bash' >> ~/testPrintSemesterWeek.sh
echo >> ~/testPrintSemesterWeek.sh
type printSemesterWeek | sed '1d' >> ~/testPrintSemesterWeek.sh
echo >> ~/testPrintSemesterWeek.sh
echo 'printSemesterWeek "$@"' >> ~/testPrintSemesterWeek.sh
chmod u+x ~/testPrintSemesterWeek.sh
EOF


debugf() { # debug a function (by placing it in a script file and running it with bash -x)
	# usage: $FUNCNAME <FUNCTION_NAME> <FUNCTION_ARUGMENTS>
	local functionName=$1
	# create a script file to put the function
	local scriptName="/tmp/test${1^}.sh"	# man bash -> Parameter Expansion -> Case modification

	shift # shift to get rid of the function name and have $@ equal to the function's argumentss
	>| $scriptName # clear the script file
	echo '#!/bin/bash' >> $scriptName
	echo >> $scriptName
	set -o pipefail # propagate the error through pipe, if the function was not found and then stop
	type $functionName 2> /dev/null | sed '1d' >> $scriptName || { err 1 "function $functionName not found"; return; } # put the function definition in the script
	set +o pipefail	
	echo >> $scriptName
	echo $functionName '"$@"' >> $scriptName # put the call to the function in the script
	chmod u+x $scriptName # make the script executable
	echo "Running $scriptName"
	bash -x $scriptName "$@" # run the script
}

highlight() { # highlight patterns in a file using grep  
    # searched: grep but show everything
    # solution: https://unix.stackexchange.com/a/367/497730
    # from: https://unix.stackexchange.com/questions/366/convince-grep-to-output-all-lines-not-just-those-with-matches
    local file_arg
    if [ $# -lt 2 ]; then
        echo "usage: $FUNCNAME <pattern> <file1> [file2 ...]"
    elif [ $# -gt 2 ]; then
        file_arg="${@:2}"
    else
        file_arg="$2"
    fi
    grep --color -E "$1|$" $file_arg ; 
    #grep --color -E "$1|$" "${@:2}" ; 

}

highlight2() { # grep everything https://unix.stackexchange.com/questions/366/convince-grep-to-output-all-lines-not-just-those-with-matches
    grep --color -E "$1|$" "${@:1}"
}


ffmpeg_convert() { # to convert mkv to mp4, based on ffmpeg_template alias
    /usr/bin/ffmpeg -i $1 -c copy $2
}

dpkg-log-status-installed() {
    \grep --color "status installed ${1}" /var/log/dpkg.log
}

dpkg-log() {
    \grep --color "${1}" /var/log/dpkg.log
}


gsettings-details() {
    echo GET
    gsettings get $@
    echo

    echo RANGE
    gsettings range $@
    echo

    echo DESCRIBE
    gsettings describe $@
    echo
}

find1() { # does find / <OPTIONS>, while excluding certain directories
	# source: https://stackoverflow.com/a/25113492 from https://stackoverflow.com/questions/13460482/exclude-a-sub-directory-using-find 
	# IDEA: if <OPTIONS> = "-s" then print the directories
	# TODO: read the list of directories from the file and replace new line with |
    local pattern=$(grep -E -v "^$|^#" $DOTS/find-skipped-directories.txt | paste -sd "|")
	sudo find / -regextype posix-extended -regex "$pattern" -prune -o "$@"
}


fdatetscsplit() {
    # the pattern is the from fdatetspattern, but converted to BRE
    csplit $1 '/^[0-9]\{4\}\(-[0-9]\{2\}\)\{2\} [0-9]\{2\}:[0-9]\{2\}/' '{*}'
    ls xx* | sort -r | xargs cat >> xx-rejoined_$(date +%Y-%m-%d_%H-%M-%S).txt
}


get-file-extension() {
    # usage: get-basename-extension <FILE>
    echo "${1##*.}"
}

get-file-extensionless() {
    # usage: basename-extensionless <FILE>
    # NOTE that if there is no extension, the whole basename is returned
    echo "${1%.*}"
}

backup3() { # backup files
  extension="${1##*.}"
  filepathWithoutExtension="${1%.*}"

  backupFilepath="${filepathWithoutExtension}_$(date +%Y-%m-%d_%H-%M-%S)"
  [ "$extension" != "$(basename "$1")" ] && backupFilepath="$backupFilepath.$extension"

  cp "$1" "$backupFilepath"
}

pdfs2png() {
    # usage: pdfs2png <PDF file>
    for filepath in "$@"; do
        local f="$(get-file-extensionless $filepath)"
        echo $filepath
        filepath="$(realpath "$filepath")"
        #echo $f

        mkcd "$f"

        #echo $PWD
        pdf2png "$filepath"

        cd "$OLDPWD"
    done
}

file-fs() { # get the filesystem of a file
    df "$1" | awk 'NR == 2 {print $1}'
}


file-stat() { # work only on ext4 files
    local file
    file=$1; sudo debugfs -R "stat <$(stat -c %i "$file")>" $(file-fs $file)

}

tmount() { # toggle mount
    # linux check if directory is mounted https://unix.stackexchange.com/questions/151390/how-to-check-whether-a-particular-directory-is-mounted
    [ $# -ne 1 ] && {
        echo "Usage: $FUNCNAME <DIR>"
        return 1
    }

    if mountpoint -q $1; then 
        sudo umount $1 &&
        echo "tmount: unmounted $1"
    else
        sudo mount $1 &&
        echo "tmount: mounted $1"
    fi
}

file-stat-ntfs() {
    # source: linux find crtime on ntfs https://unix.stackexchange.com/questions/87265/how-do-i-get-the-creation-date-of-a-file-on-an-ntfs-logical-volume/
    local file
    file=$1; sudo ntfsinfo -F $file /dev/nvme0n1p8
}


gitignore() {
    # usage: $FUNCNAME <type> [-f]
    # def: outputs a gitignore file, for the language specified by the argument, from https://github.com/github/gitignore 
    #  if argument -f is provided, content is written to a file .gitignore

    [ -z "$1" ] && { err 1 "must provide an argument"; return; }

    local name=""
    local outputDocument=""
    local link

    case $1 in 
        c) name="C";;
        cpp) name="C++";;
        cs) name="VisualStudio";;
        java) name="Java";;
        jetbrains) name="Global/JetBrains";;
        python) name="Python";;
        qt) name="Qt";;
        unity) name="Unity";;
    esac
    [ -z $name ] && { err 1 "language type not found"; return; }

    link="https://raw.githubusercontent.com/github/gitignore/main/$name.gitignore"

    [ "$2" == "-f" ] && outputDocument=".gitignore" || outputDocument="/dev/stdout"
    wget --quiet --output-document=- $link >> $outputDocument
}


psgrep() { # ps grep
  # ps aux grep https://askubuntu.com/questions/157075/why-does-ps-aux-grep-x-give-better-results-than-pgrep-x
  ps wup $(pgrep -f "$1")
}

xfracf() { # XFreeRDP Artsoft Consult Fullscreen
  xfreerdp /v:"${SOGO_STATION_IP}" /u:"${SOGO_USERNAME}" /p:"${SOGO_PASSWORD}" /f
}

xfracm() { # XFreeRDP Artsoft Consult Multimonitor
  xfreerdp /v:"${SOGO_STATION_IP}" /u:"${SOGO_USERNAME}" /p:"${SOGO_PASSWORD}" /multimon
}

xfracfm() { # XFreeRDP Artsoft Consult Fullscreen Multimonitor
  xfreerdp /v:"${SOGO_STATION_IP}" /u:"${SOGO_USERNAME}" /p:"${SOGO_PASSWORD}" /f /multimon
}

fix-camera() {
  # usage: fix-camera <patch file>
  # source: https://askubuntu.com/questions/1264173/how-to-fix-camera-on-ubuntu-20-04

  # how to create .patch files?
  # git diff --no-index uvc_driver.c uvc_driver.c.1 | sed -E 's@\<(uvc_driver.c)[^ ]+\>@\1@g' >| /mnt/e/dotfiles/linux-patches/uvc_driver-for-Quanta-HD-User-Facing-0x0408-0x4035_5.15.0-58-generic.patch


  [ -f "$1" ] || { echo "Usage: $FUNCNAME <patch file>"; echo "Error: patch file not found"; return 1; }

  local currentDir="$PWD"
  cd /tmp && mkcdfdate

  echo "Enable source code repositories" # https://askubuntu.com/questions/158871/how-do-i-enable-the-source-code-repositories
  sudo "${DOTSB}"/mintsources2.py enable

  apt-get source linux-modules-extra-"$(uname -r)"
  [ "$(/usr/bin/ls -d linux-*/ | wc -l)" -eq 1 ] || { echo "Error: more than one directory found"; return 1; }
  cd "$(/usr/bin/ls -d linux-*/)"drivers/media/usb/uvc || { echo "Error: directory not found"; return 1; }

  echo "Apply patch"
  git apply -v "$1" || { echo "Error: patch failed"; return 1; }

  make -j4 -C /lib/modules/"$(uname -r)"/build M="$(pwd)" modules
  sudo cp uvcvideo.ko /lib/modules/"$(uname -r)"/kernel/drivers/media/usb/uvc/

  sudo rmmod uvcvideo && sudo modprobe uvcvideo


  echo "Disable source code repositories"
  sudo "${DOTSB}"/mintsources2.py disable


  echo "Now test the camera"
  cd "$currentDir" || { echo "Error: directory not found"; return 1; }
}

#default-gateway-open() {
#    (echo $(xdg-open http://$(ip route | grep default | awk '{print $3}' | head -n1) &))
#}


setup-ssvv-testlink-and-jenkins() { # for S6.SSVV
  # $1 = location of VVSS-how-to-docker

  if [ -z "$1" ]; then echo "must provide a location for VVSS-how-to-docker"; return; fi

  if [ "$(docker ps -a --format "{{.ID}}" | wc -l)" -ne 0 ]; then
    read -rp "Docker containers are present. Do you want to stop and remove them all? [y/n] " answer
    if [ "$answer" == "y" ]; then docker rm $(docker stop $(docker ps -aq)); else echo "user gave negative answer, exiting"; return; fi
  fi

  cd "$1"/step1/


  cd ./step2/

  docker load -i bitnami-mariadb.tar
  docker load -i bitnami-testlink.tar
  docker load -i vvss-jenkins.tar

  cd ./step3/
  chmod o+w -vR ./mariadb_data/data/
  chmod o+w -vR ./testlink_data/upload_area/

  docker compose up
}

scriptpath() {
  return "$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
#  return "$(dirname "$(readlink -f "$0")")" # also works w/
}

opf() {
    (xdg-open "$@" &)
}


chrome-left() {
    local order="${1:-1}"

    # Get the window ID of the Google Chrome instance using wmctrl
    local window_id
    window_id=$(wmctrl -l | grep "Google Chrome" | awk -v order="$order" '{if (NR == order) print $1}')

    # If window_id is not empty, move the window
    if [ -n "$window_id" ]; then
        wmctrl -ir "$window_id" -b remove,maximized_vert,maximized_horz
        wmctrl -ir "$window_id" -e 0,0,20,1240,790
        echo "Moved Google Chrome instance $order to the left."
    else
        echo "Google Chrome instance $order not found."
    fi
}


chrome-mid() {
    local order="${1:-1}"

    # Get the window ID of the Google Chrome instance using wmctrl
    local window_id
    window_id=$(wmctrl -l | grep "Google Chrome" | awk -v order="$order" '{if (NR == order) print $1}')

    # If window_id is not empty, move the window
    if [ -n "$window_id" ]; then
        wmctrl -ir "$window_id" -e0,1280,0,1920,1047
        wmctrl -ir "$window_id" -b add,maximized_vert,maximized_horz
        echo "Moved Google Chrome instance $order to the left."
    else
        echo "Google Chrome instance $order not found."
    fi
}


mvchr() {
    local direction="$1"
    local order="${2:-1}"

    # Validate direction
    case "$direction" in
        "left" | "center" | "right")
            ;;
        *)
            echo "Invalid direction. Usage: mvchr <left|center|right> [<order>=1]"
            return 1
            ;;
    esac

    # Get the window ID of the Google Chrome instance using wmctrl
    local window_id
    window_id=$(wmctrl -l | grep "Google Chrome" | awk -v order="$order" '{if (NR == order) print $1}')

    # If window_id is not empty, perform the specified move based on direction
    if [ -n "$window_id" ]; then
        case "$direction" in
            "left")
                wmctrl -ir "$window_id" -b remove,maximized_vert,maximized_horz
                wmctrl -ir "$window_id" -e 0,0,20,1280,768
                echo "Moved Google Chrome instance $order to the left."
                ;;
            "center")
                wmctrl -ir "$window_id" -b remove,maximized_vert,maximized_horz
                wmctrl -ir "$window_id" -e0,1280,0,1920,1047
                wmctrl -ir "$window_id" -b add,maximized_vert,maximized_horz
                echo "Moved Google Chrome instance $order to the center."
                ;;
            "right")
                wmctrl -ir "$window_id" -b remove,maximized_vert,maximized_horz
                wmctrl -ir "$window_id" -e0,3200,0,1920,1047
                wmctrl -ir "$window_id" -b add,maximized_vert,maximized_horz
                echo "Moved Google Chrome instance $order to the right."
                ;;
        esac
    else
        echo "Google Chrome instance $order not found."
    fi
}


ac::internal::wl_ok() {
    local last_modified=$(stat -c %Y /home/kamui/.config/google-chrome/Default/cookie-wol)
    local current_time=$(date +%s)
    local time_diff=$((current_time - last_modified))
    local char_count=$(wc -c < /home/kamui/.config/google-chrome/Default/cookie-wol)
    [ "$time_diff" -le 30 ] && [ "$char_count" -ge 420 ]
}

ac::internal::wp_ok() {
    [ -n "$1" ] && jq -e '.success == "OK"' <<< "$1" > /dev/null && \
     jq -e 'has("data") and (.data | has("result")) and (.data.result | has("alive"))' <<< "$1" > /dev/null
    # testing: src; ac::internal::wolp_ok "$(cat $(ls -rt | tail -1))"; echo $?
}

ac::internal::wp_alive() {
    jq -e '.data.result.alive == true' <<< "$1" > /dev/null
    # testing: src; ac::internal::wolp_alive "$(cat $(ls -rt | tail -1))"; echo $?
}

ac::internal::ww_ok() {
    cat | grep -E -q "^(200|304)$"
    # test: src; curl -s --fail --show-error https://httpbin.org/status/204 -w "%{http_code}\n" | ac::internal::ww_ok; echo $?
}

acvs() { # ac vpn status
    nmcli con show --active | grep -q "ssl_artsoft"
    local result=$?
    [ "$1" = "-q" ] && return $result
    [ "$result" -eq 0 ] && echo "VPN is connected" || echo "VPN is not connected"
    return $result
    # test: src; acvsq; echo $?; echo; acvs
}

acvsq() { # ac vpn status quiet
    acvs -q
}

acvc() { # ac vpn connect
    # https://www.google.com/search?q=ubuntu+connect+to+vpn+command+line -> https://askubuntu.com/questions/57339/connect-disconnect-from-vpn-from-the-command-line
    acvs || nmcli con up id ssl_artsoft
}

acvd() { # ac vpn disconnect
    acvs && nmcli con down id ssl_artsoft
}

acwl() { # ac wol login
local execution="$(curl -s "https://cas.artsoft-consult.ro:8443/cas/login?service=http%3A%2F%2Fwol.artsoft-consult.ro%2F&renew=true" | \grep -oP '<input[^>]*name="execution"[^>]*value="\K[^"]*')"
curl --silent --show-error -c /home/kamui/.config/google-chrome/Default/cookie-wol \
    --location 'https://cas.artsoft-consult.ro:8443/cas/login?service=http://wol.artsoft-consult.ro/&renew=true' \
    --data-urlencode 'username=sandrinopatrulescu' \
    --data-urlencode "password=${SOGO_PASSWORD}" \
    --data-urlencode "execution=${execution}" \
    --data-urlencode '_eventId=submit' \
    -o /dev/null
#    -w "%{http_code}\n"
}

acwp() { # ac wol ping
curl --silent --show-error -b /home/kamui/.config/google-chrome/Default/cookie-wol \
    --location 'https://wol.artsoft-consult.ro/ping' \
    --header 'Content-type: application/json; charset=UTF-8' \
    --data '{"host":false}'
#    -w "\n%{http_code}\n"
}

acww() { # ac wol wake
curl --silent --show-error -b /home/kamui/.config/google-chrome/Default/cookie-wol \
    --location 'https://wol.artsoft-consult.ro/wake' \
    -w "\n%{http_code}\n"
}

acrc() { # ac remmina connect
    remmina -c /home/kamui/.local/share/remmina/group_rdp_artsoft-172_10-79-254-172.remmina >/dev/null 2>&1 &
}

acrd() { # ac remmina disconnect
    remmina -q
}

acds() { # artsoft consult disconnect, w/o skype
    acrd
    acvd
}

acd() { # artsoft consult disconnect, opposite to acc bin/ script
    killall -15 skypeforlinux
    acds
    exit
}

ytdlp() {
    mkdir -p /tmp/{send,sent}
    yt-dlp -P "${2:-/tmp/send}" "$1"
}

il1() {
    instaloader --no-video-thumbnails --dirname-pattern="${2:-/tmp}" --no-captions --no-metadata-json --filename-pattern={date}_{shortcode} -- \
     -$(echo "$1" | grep -oE '/p/[^/]+/' | sed 's|/p/||;s|/||')
}

webm2mp4() {
    ffmpeg -i "$1" -c:v libx264 -c:a aac -strict experimental "$(echo "$1" | sed -E 's@\.[^.]+$@@').mp4"
}

localhosts() {
    # https://www.google.com/search?q=linux+command+line+view+all+lan+devices -> https://superuser.com/a/1195142
    ip neigh | awk '{ print $1 }' | xargs -I % sh -c 'echo % $(host %)'
}

localhost() {
    [ -n "$1" ] || { echo "usage: $FUNCNAME <hostname>"; return 1; }
    localhosts | grep "$1" | awk '{ print $1 }'
}

pic() { # pi connect
    ssh "repo@${PI_IP}"
}

shutdown1s() {
    echo "Sleeping $1 seconds then shutting down"
    sleep $1
    pkill -15 -f firefox
    pkill -15 -f chrome
    cleanup
    shutdown +0
}

shutdown1m() {
    shutdown1s $((60 * $1))
}


ba() { # imogen băbăbăbăbăbăbăbă
    seq ${1:-8} | awk '{printf "bă"} END {printf "\n"}' |  tee >(xargs echo -n | xclip -selection clipboard -i)
}



git-commit-date() {
    # git change commit date -> https://stackoverflow.com/a/454750/17299754
    local revision="$1"
    local date_="$2" # format: ISO or "2021-08-01 12:00:00" (https://git-scm.com/docs/git-commit#_date_formats)

    local param="$(echo 'if [ $GIT_COMMIT = <REVISION> ]
                                 then
                                     export GIT_AUTHOR_DATE="<DATE>"
                                     export GIT_COMMITTER_DATE="<DATE>"
                                 fi' | sed -E "s@<REVISION>@$revision@g;s@<DATE>@$date_@g")"

    echo $param
    git filter-branch --env-filter "$param"
}

discord-update() {
    local url="https://discord.com/api/download/stable?platform=linux&format=deb"
    local currentISODate="$(date -Ins | sed -E 's@.{6}$@@;s@,@.@g;s@:@-@g;s@T@_@')" # up to nanoseconds
    local location="/tmp/$currentISODate"

    echo "Downloading discord from $url to $location"

    # wget default filename -> https://unix.stackexchange.com/a/453471/497730 -> --content-disposition
    wget --content-disposition --directory-prefix "$location" "$url" || { echo "Error: wget failed"; return 1; }

    local basename="$(ls -1 "$location")"
    [ "$(echo "$basename" | wc -l)" -eq 1 ] || { echo "Error: more than one file in $location"; return 1; }

    # NOTE that -R might be dangerous but this is the method that I found to work
    sudo dpkg -R -i "${location}"
}

networks-online() {
    ip link | awk -F': ' '$0 ~ "state UP" {print $2}'
}

network-devices() {
    # linux list all lan devices -> https://superuser.com/a/1137004/1567684
    # TODO IDEA: pass BASE_IP as argument and create an alias `network-devices1` that calls the function with it
    nmap -sL "${BASE_IP}.*" | awk -F' ' '$NF~/\([0-9]{1,3}(\.[0-9]{1,3}){3}\)/ {print substr($NF, 2, length($NF) - 2)" "$(NF-1)}'
}

network-cards() {
    sudo lshw -C network
}

pare() { # panel restart
    kill -15 "$(pgrep xfce4-panel)"
    (xfce4-panel >/dev/null 2>&1 &)
}

hostfilestmp() {
    [ -d /tmp/public ] || mkdir /tmp/public
    hostfiles /tmp/public
}

screenlocktimetoggle() {
    # monitoring changes: xfconf-query -mv -c xfce4-power-manager
    # find current values: xfconf-query -cv xfce4-power-manager -l | grep blank
    local enabled=$1

    if [ "$enabled" = "true" ]; then
        xfconf-query -c xfce4-power-manager -p /xfce4-power-manager/blank-on-ac -s 5
        xfconf-query -c xfce4-power-manager -p /xfce4-power-manager/blank-on-battery -s 5
    else
        xfconf-query -c xfce4-power-manager -p /xfce4-power-manager/blank-on-ac -s 0
        xfconf-query -c xfce4-power-manager -p /xfce4-power-manager/blank-on-battery -s 0
        enabled=false
    fi
    echo "Screen lock time is now $enabled"
}
# }}}

psgrept() { # ps grep total
  # linux print mb in human format https://unix.stackexchange.com/questions/44040/a-standard-tool-to-convert-a-byte-count-into-human-kib-mib-etc-like-du-ls1
  echo "$1 memory usage: ~$(ps wup $(pgrep -f "$1") | awk '{sum += $6} END {print sum}' | numfmt --to=iec-i --suffix=B --from-unit=1000)"
}



    ### COMPILE ### ------------------------------ {{{

qtbuild() { # compile c++ qt apps in the cli
    [ -f main.cpp ] || 
    cat > main.cpp << EOF
#include <QApplication>
#include <QWidget>

int main(int argc, char* argv[]) {
    QApplication app(argc, argv);
    QWidget mainWidget{};
    mainWidget.show();
    return QApplication::exec();
}
EOF

    [ -f ./*.pro ] || qmake -project

    grep -q "^TARGET.*\.out" *.pro || sed -Ei 's@^(TARGET[ ]+=.+)@\1.out@' *.pro 

    # https://stackoverflow.com/questions/2580934/how-to-specify-different-debug-release-output-directories-in-qmake-pro-file
    /usr/bin/grep -q "QT += widgets" *.pro || 
    cat >> *.pro << EOF
QT += widgets

debug:DESTDIR = debug
debug:OBJECTS_DIR = \$\${DESTDIR}/.obj
debug:MOC_DIR = \$\${DESTDIR}/.moc
debug:RCC_DIR = \$\${DESTDIR}/.rcc
debug:UI_DIR = \$\${DESTDIR}/.ui
EOF

    #echo 'QT += widgets' >> *.pro
    qmake
    make && ./debug/*.out
}


# edit c file in vi
vc() { # edit .c files (extension shouldn't be written)
    vi "$1".c
}


## compile c file TODO: compare this with the template maker and then remove it
#ccc()  {
#    # Note: output path:
#    #       - can be replaced with the argument "-o <output path>"
#    #       - should provide the name of the resulting file (extension included, if wanted) or the path to <name>.out
#    #       - example:
#    #           ccc -o out/main.out
#    #               or 
#    #           ccc -o main.elf
#    #               or
#    #           ccc -o /tmp/main.out
#    #               or
#    #           ccc -o ../dir1/dir2/<...>/dirn/main.elf
#    #               or
#    #           ccc -o ./out/main.elf
#
#
#    # set default compile-time arguments
#    COMPILE_ARGS="-Wall -pedantic -g"
#    unset OUTPUT_PATH    
#
#    # parse the provided arguments for compiler arguments (they start with a "-" (dash))
#    while [[ "$1" = -* ]]; do
#        [[ "$1" = -o ]] && { # replaces -o <name>.out with a custom path
#            shift
#            OUTPUT_PATH="$1"
#            shift
#            continue
#        }
#        COMPILE_ARGS="$COMPILE_ARGS $1"
#        shift
#    done
#
#    # make sure a filename is provided
#    [[ $# -lt 1 ]] && { echo "usage: $FUNCNAME [-<gcc arg>...] <name of c source WITHOUT extension> [<runtime arg>...]"; false; return; } 
#
#    # final set for the output path
#    FILENAME="$1"
#    [ -z $OUTPUT_PATH ] && OUTPUT_PATH="${FILENAME}.out" # set default output option -o is not given
#    [ -d "$OUTPUT_PATH" ] && { [[ "$OUTPUT_PATH" =~ /$ ]] && OUTPUT_PATH="${OUTPUT_PATH}${FILENAME}.out" || OUTPUT_PATH="${OUTPUT_PATH}/${FILENAME}.out"; }  # set default output file for directory given to -o option
#
#
#    # generate default c source file if none exists
#    [[ ! -f "${FILENAME}.c" ]] && 
#cat << end_str >> "${FILENAME}.c"
##include <stdio.h>
#
#int main(int argc, char **argv) {
#    
#
#    return 0;
#}
#end_str
#
#    # make a backup of the output file
#    [[ -f "${OUTPUT_PATH}" ]] && cp "${OUTPUT_PATH}" "${OUTPUT_PATH}".old
#
#    # print the compiler arguments
#    echo "\$COMPILE_ARGS=$COMPILE_ARGS -o ${OUTPUT_PATH}"
#
#    # compile the file
#    gcc $COMPILE_ARGS -o "${OUTPUT_PATH}" "${FILENAME}.c" || return $?
#
#    # run the program
#    shift # get rid of the filename in the function arguments
#    echo "--> Compilation done, now starting ${OUTPUT_PATH} <--" # print a message to know where program run starts
#    # if OUTPUT_PATH is not a path (by path, i mean: contains at least 1 '/' (forward slash)), prepend './' to it in order to run it
#    grep -q "/" <<< "$OUTPUT_PATH" && "$OUTPUT_PATH" $@ || ./"${OUTPUT_PATH}" $@
#    
#}
#

# added at 16.11.2021 22;49
jr() { # compile java file or create
    [ $# -lt 1 ] && { echo "Please proide just the name of the .java file and the program args"; false; return; }
    JAVA_FILE_NAME="$1"
    FULL_NAME="${1}".java
    [ ! -f "${FULL_NAME}" ] &&
cat << end_str >> "${FULL_NAME}"

public class ${JAVA_FILE_NAME} {
    public static void main(String[] args) {
        
    }
}

end_str
    $JAVA_HOME/bin/javac -Xlint:all "${FULL_NAME}"
    [ $? -eq 0 ] && { shift; echo "--> Compilation done, now starting ${JAVA_FILE_NAME}.class <--"; $JAVA_HOME/bin/java "${JAVA_FILE_NAME}" $@; }

    # javafxc -d out/production/A7/ $(find src/ -name "*.java") &&
    # javafx -classpath out/production/A7/ view.Main
}

# 39 hash characters below
#######################################
# Compile and run JavaFX programs
#
# Globals:
#   JAVA_HOME
#   ?
#
# Arguments 1:
#   optional: -d Directory to place the class files, a path
#   Directory where .java files are located, an EXISTENT path
#   Starter class's full name, ex: [package1.][package2.]...[packageN.]MyClass
#   optional - Arguments for the JavaFX program
#   
# Arugments 2:
#   optional: -d Directory to place the class files, a path
#   Source file, path to an EXISTENT .java file
#   optional - Arguments for the JavaFX program
# 
# Outputs:
#  -> the output of the JavaFX program
#    
# Returns:
#   0, on success
#   64, JAVAFX_ARGS is unset
#   65, Source file/directory not found
#   66, Source file doesn't end in .java
# Purpose:
#   Replace javafxc -d out/production/A7/ \ 
#   $(find src/ -name "*.java") && javafx \
#   -classpath out/production/A7 view.Main
#   with 
#   jfxr out/production/A7 src/ view.Main
#
#######################################
jfxr() { # Compile and run JavaFX programs

    # usage:
    local usage
    usage="\nusage:"
    usage+="\n$FUNCNAME [-d <DIR_FOR_CLASS_FILES>] <DIR_OF_SOURCE_FILES> <STARTER_CLASS_FULLNAME>"
    usage+="\n$FUNCNAME [-d <DIR_FOR_CLASS_FILE>] <SOURCE_FILE>"
    usage=$(echo -e $usage)

    # echo -e "$USAGE" # without quotes, it would convert the whitespaces into a single one, since it would be giving different arguments to echo
     
    # test if JAVAFX_ARGS is set
    if [ -z ${JAVAFX_ARGS+x} ]; then err 64 "JAVAFX_ARGS is unset$usage"; return; fi # check if a variable is set https://stackoverflow.com/a/13864829/17299754 
    
    local compile_args
    local run_args
    local starter_name

    # arguments parsing
    
    # test if output directory option is given
    if [ "$1" = "-d" ];
    then
        # set the output directory / classpath
        compile_args+=" -d $2"
        run_args+=" -classpath $2"

        shift 2 # move to next arugments
    fi

    # source file vs source directory
    # if it is a file
    if [ -f "$1" ];
    then
        # make sure it  ends in .java
        if [[ ! "$1" = *.java ]]; then err 66 "Source file: $1 doesn't end in .java$usage"; return; fi
        compile_args+=" $1"
        run_args+=" $1"
        starter_name=$(basename $1)
        shift; # move to next arguments
    elif [ -d "$1" ];
    then
        compile_args+=" $(find $1 -name "*.java")"
        run_args+=" $2" 
        starter_name=$2
        shift 2 # move to next arguments
    else
        err 65 "Source file/directory: $1 not found$usage"; return
    fi
    


    # compile
    #echo compile_args=$compile_args
    $JAVA_HOME/bin/javac $JAVAFX_ARGS $compile_args || return $? # compile successfully or return the error code of javac 

    echo "--> Compilation done, now starting ${starter_name/.java/} <--"
    # run
    #echo run_args=$run_args
    $JAVA_HOME/bin/java $JAVAFX_ARGS $run_args "$@"  


}


runc() { # used for creating C programs to use with THREADS
if test $# -eq 0
then
    echo -e "ERROR: Must provide at least a name to the C program"
    false; return
else
    #if cat test.c | grep -Eqc "int main()"; then echo "found main"; else echo "not found"; fi
    if [ ! -f "$1.c" ]
    then
        echo '#include <stdio.h>' > "$1.c"
	    echo "" >> "$1.c"
	    echo "" >> "$1.c"
	    echo 'int main(int argc, char *argv[]) {' >> "$1.c"
	    echo '    printf("Hello, world!\n");' >> "$1.c"
	    echo "" >> "$1.c"
	    echo "    return 0;" >> "$1.c"
	    echo "}" >> "$1.c"
	    echo "" >> "$1.c"
    fi
    gcc -Wall -pedantic -g "$1.c" -o "$1.out" -pthread 
    NAME="$1"
    shift
    #echo "$@"
    ./"$NAME.out" $@ 
fi

}

cfc() { # c fast compile
    local out=${1/.c/.out}
    gcc -Wall -o $out $1 && ./$out
}

cpfc() { # c++ fast compile
    local out=${1/.c/.out}
    gcc -Wall -o $out $1 && ./$out
}

ccfc() { # c/c++ fast compile
    local compiler
    local out=
    out=${1/.cpp/.out}
    out=${1/.c/.out}
    [[ $1 == *.c ]] && compiler=gcc || compiler=g++
    source_file="$1"
    shift    
    $compiler -Wall -o $out $source_file && ./$out "$@"
}

g++2() {
    local out_file="${1%.*}" # bash remove all extensions https://stackoverflow.com/questions/965053/extract-filename-and-extension-in-bash
    shift

    g++ -Wall -o $out_file.out "${out_file}.cpp" && ./$out_file.out "$@"
}

# }}}



    ### FS Management ### {{{


# make file backups with timestamp inside the name

# be careful not to include the tralining / (slash) for directories
#   unless you want to copy inside the given directory
backup() { # copy a file/folder and append $(date +%Y-%m-%d_%H-%M-%S) to the name
    [ $# -lt 1 ] && { echo "Please provide at least 1 file name/path"; false; return; }
        
    local file="$1"
    # %/ used to avoid creating an additional directory
    # see rsync manual usage nr 4
    [ $# -eq 1 ] && { rsync -avP "$file" "${file%/}$(date +%Y-%m-%d_%H-%M-%S)"; return; } 

    [ $# -gt 1 ] && {
        while [ $# -ne 0 ]; do
            rsync -avP "$file" "$file$(date +%Y-%m-%d_%H-%M-%S)"
            shift
        done
        return

    }
}


backup2() { # abandoned
    [ $# -lt 2 ] && { echo "usage: $FUNCNAME CASE SRC... [DEST]"; echo "CASE=1..4"; false; return; }

    # case 1: SRC DEST
    [ "$1" -eq 1 ] && rsync -avP "$2" "$3$(date +%Y-%m-%d_%H-%M-%S)"

    # case 2: SRC
    [ "$1" -eq 2 ] && rsync -avP "$1" "$(basename "$1")$(date +%Y-%m-%d_%H-%M-%S)"

    # case 3: SRC... DEST
    [ "$1" -eq 3 ] && rsync -avP 

    # case 4: SRC...
    [ "$1" -eq 4 ] && rsync -avP 

    [ "$1" -lt 1 ] || [ "$1" -gt 4 ] && echo "CASE must be in range 1..4" && false
}



big() { # display files/dirs sorted in reverse by size
    # usage: big
    #   or
    #  big <dir_followed_by_slash>
    #
    # !!! add / (slash) after directory
    local start=`date +%s%N`
    du -sch ${1}{.[^.],}* | sort -h
    local end=`date +%s%N`
    echo "Execution time was $(echo "scale=9; ($end - $start) / 10^6" | bc | sed -E 's@(\.[0-9]{3}).*@\1@') miliseconds."
}


sbig() { # same as big() but using sudo
    # usage: same as for big()
    local start=`date +%s%N`
    sudo du -sch ${1}{.[^.],}* | sort -h
    local end=`date +%s%N`
    echo "Execution time was $(echo "scale=9; ($end - $start) / 10^6" | bc | sed -E 's@(\.[0-9]{3}).*@\1@') miliseconds."
}

# example:
#   ./changeName.sh foo bar
#   results in:
#       foo.class -> bar.class
#       foo.java -> bar.java
changeName() {
       
    [ $# -eq 2 ] || { echo "usage: $FUNCNAME <path/to/file/with/out/extension> <new/name/without/extension>"; false; return; }
    
    for FILE in ${1}.*; do
        [ -e "$FILE" ] || continue
    
        EXT=$(echo $FILE | awk -F. '{print $2}')
        echo "${FILE%.*}.$EXT -> ${2}.$EXT" 
        #echo "${FILE} -> ${2}.$EXT" 
                                                                                    
        mv -- "$FILE" "${2}.$EXT" # should it be mv -v ?
    done
}


findSkipDirs() { # skip folders using find
    USAGE="usage: findSkipDirs -p|n <file_with_dirs|dirs...>"

    # check and set the mode
    unset MODE
    [ "$1" = "-p" ] && MODE="-path"
    [ "$1" = "-n" ] && MODE="-name"
    [ -z "$MODE" ] && { echo $USAGE; return 1; }

    # set the mode for receving the directory names/paths
    [ -f "$2" ] && DIRS=$(cat "$2") || { shift; DIRS=$@; }


    COUNT=0
    echo -n " -type d \( "
    for DIR in $DIRS; do
        [ $COUNT -eq 0 ] || echo -n "-o "
        echo -n $MODE "${DIR%/} "  
        COUNT=$((COUNT+1))
    done
    echo "\) -prune -o"
    echo "!!! paste it while the cursor is on the first space after the search location"
    echo
    echo "example 1: "
    echo 'sudo find / -type d -type d \( -name Google -o -name timeshift \) -prune -o -iname "*jetbrains*" -print'
    echo "example 2: "
    echo '_ find / -type d \( -path /mnt -o -path /home/timeshift -o -path /proc \) -prune -o -iname "*cxoffice*" | tee --append find-output_$(date +%Y-%m-%d_%H-%M-%S).txt'
    #sudo find . -type d \( -path ./.cache/Google -o -path ./.mozilla/firefox \) -prune -o -iname "*jetbrains*" -print

    # Notes: name + -print doesn't work
    # testable with
    # rm /tmp/find-w-print.txt; date; time sudo find / -type d -type d \( -name Google -o -name timeshift \) -prune -o -iname "*jetbrains*" -print | tee --append /tmp/find-w-print.txt; date
    # rm /tmp/find-wo-print.txt; date; time sudo find / -type d -type d \( -name Google -o -name timeshift \) -prune -o -iname "*jetbrains*" | tee --append /tmp/find-wo-print.txt; date
    # diff --color=auto /tmp/find-w-print.txt /tmp/find-wo-print.txt
}

# not used
multiinf() { # provide various system info (used at fresh installs, see Evernote/Linux install + configs)
    # before: >sudo echo; clear # + Ctrl + L
    echo "multiinf() at $(date +%Y-%m-%d_%H-%M-%S):"
    echo -n " kamui  ~  "; date; sudo fdisk -l
    echo -n " kamui  ~  "; date; df -h | grep -v tmpfs
    echo -n " kamui  ~  "; date; df | grep -v tmpfs
    echo -n " kamui  ~  "; date; blkid
    echo -n " kamui  ~  "; date; sudo du -sch /{.[^.],}* --exclude=/home --exclude=/mnt --exclude=/proc --exclude=/usr | sort -h # <=> sbig /
    echo -n " kamui  ~  "; date; sudo du -sc /{.[^.],}* --exclude=/home --exclude=/mnt --exclude=/proc --exclude=/usr | sort -h
    echo -n " kamui  ~  "; date; sudo du -sch ~/.cache/{.[^.],}* | sort -h
    echo -n " kamui  ~  "; date; ls -1 ~/.cache
    echo -n " kamui  ~  "; date; sudo du -sch ~/.config/{.[^.],}* | sort -h
    echo -n " kamui  ~  "; date; ls -1 ~/.config
    echo -n " kamui  ~  "; date; sudo du -sch ~/.local/share/{.[^.],}* | sort -h
    echo -n " kamui  ~  "; date; ls -1 ~/.local/share
    echo -n " kamui  ~  "; date; apt list --installed

}

sprune() {
    echo -n "find . -iname \"*\""
    for ARG in $DIR_LINES
    do
        # [ -d "$ARG" ] && # test whether it's a directory
        echo -n " -path \"$ARG\" -prune" # note the space at the end of the string
    done
    echo
}


tot() { # to trash - move files/dirs to trash and log the date and reason
# aka to trash
    # usage: $FUNCNAME <file_to_trash> [-l <location>] <REASON>
    #   ex: tot script.sh -l $TRASH/removed_scripts "used to show directory size, no longer needed"


    # arguments parsing
    local file_to_trash="$1"
    local location
    if [ ! -e "$file_to_trash" ]; then err 1 "file_to_trash=$file_to_trash does not exist"; return; fi

    shift # now $@ = [-l <location>] reason

    # handle the -l parameter
    if [ "$1" = "-l" ];
    then
        location="$2"
        if ! readlink -f "${location}" | grep -q -E "^$TRASH"; then err 1 "location=${location} is not TRASH"; return; fi # more info on negation and pipelines at man bash -> SHELL GRAMMAR -> Pipelines
        if [ ! -d "${location}" ]; then err 1 "location=${location} is not a valid directory inside TRASH"; return; fi
        shift 2 # now $@ = reason
    fi 


        # -z means length 0 (aka not set or the empty string, i.e. '')
    [ -z "$TRASH" ] && { err 1 "$TRASH is not set"; return; } # test if TRASH is set
    [ -d "$TRASH" ] || { err 1 "$TRASH is not a valid dir"; return; } # test if TRASH is a valid dir


    # set location to env TRASH if not set
    
    : ${location=$TRASH} # source: https://stackoverflow.com/a/12405621/17299754

    # now $@ = reason
    if [ ! $# -ge "1" ]; then err 1 "REASON is not given"; return; fi  # check that a reason is given
    
    local full_path_to_file_to_trash="$(readlink -f "$file_to_trash")"


    local trash_log_file="$TRASH/A0_trash-log.txt"
    [ -e "$trash_log_file" ] || echo 'DATE|FILE|REASON' >> "$trash_log_file"

    mv -v "$full_path_to_file_to_trash" "$location" && echo "$(date +%Y-%m-%d_%H-%M-%S)|$full_path_to_file_to_trash|$@" >> "$trash_log_file"

}


#######################################
# tail trash: tt or tt <nr of lines> 
#   any other arugments are ignored
#######################################
tt()  # tail trash - list the last N, or last 10,  entries in the trash log file 
{ 
    local trash_log_file="$TRASH/A0_trash-log.txt"
    local args
    local lines_to_show

    # also print the header if it would be printed normally
    if [ $# -eq 1 ];
    then
        args="-n $1"
        lines_to_show="$1"
    else
        lines_to_show=10
    fi

    #echo "$lines_to_show"
    #echo "$lines_in_trash_log"
    local lines_in_trash_log=$(wc -l "$trash_log_file" | awk '{print $1}')
    [ "$lines_to_show" -lt "$lines_in_trash_log" ] && 
echo "$(head -n 1 $TRASH/A0_trash-log.txt) <--- HEADER" 
    [ "$lines_to_show" -lt $(( lines_in_trash_log - 1)) ] && echo "... $(( lines_in_trash_log - lines_to_show - 1)) more line/s" # show number of hidden lines

    tail $args "$trash_log_file"
}

# }}}



    ### NAVIGATION ### {{{

getpwd() { # print pwd
    (cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
}

# }}} 



    ### SYSTEM ANALYSIS ### {{{


mw() { # memory watcher
    while :; do
        date; 
        free -m | awk 'NR==2{printf "Percentage: %.2f%%\n", $3*100/$2}'
        free -h; 
        sleep 1; 
        clear;
    done
}


# deprecated: $1 = foo/a/a.txt must be changed to ./foo/a/.txt
sln() { # deprecated, used to create symlinks
    # sln OLD NEW
    # sln OLD # it is done in the current folder
    # TODO test if OLD exists and that NEW doesn't exists
    ERR_MSG="$(cat <<'EOS'
usage: sln OLD NEW\n
or\n
usage: sln OLD
EOS
)"
    [ $# -ge 1 -a $# -le 2 ] || { echo "$ERR_MSG"; return 1; }

    [ -e "$1" ] || { echo "sln() fail: $1 is NOT file"; return 1; }
    OLD_FILE="$1"
    NEW_LOC="."

    [ $# -eq 2 ] && [ -d "$2" ] || { echo "sln() faild: $2 is NOT a directory"; return 1; }
    NEW_LOC="$2"
    FILE_NAME="$(basename "$OLD_FILE")"
    [ -e "$NEW_LOC/$FILE_NAME" ] && { echo "sln() fail: $NEW_LOC/$FILE_NAME already exists"; return 1; }
    ln -s "$OLD_FILE" "$NEW_LOC"  && echo "$NEW_LOC -> $OLD_FILE"
}

# }}}



    ### UTILS ### {{{

#calculator awk
cawk() { # calculator
    # Note: * has to be escaped
    echo | awk "{print $*}"
}


__cleanup-dir() {
    # usage __cleanup-dir <dir>
    echo -ne "$1\t" && [ -d "$1" ] && rm -vr "$1" | wc -l || echo "Empty"
}


cleanup() { # remove temporary files
  [ "$CLEANUP_ENABLED" = false ] && { echo "CLEANUP_ENABLED is false"; return;}
  # TODO: idea: export the multimap
  declare -A multimap
  local separator="|"
#  multimap["Chrome"]="/home/kamui/.cache/google-chrome/Default/Cache/Cache_Data|/home/kamui/.cache/google-chrome/Default/Code Cache/js"
  multimap["Chrome"]="$(join1 "$separator" /home/kamui/.cache/google-chrome/*/{Cache/Cache_Data,Code\ Cache/js} /home/kamui/.config/google-chrome/*/Service\ Worker/CacheStorage)"
  multimap["Discord"]="/home/kamui/.config/discord/Cache"
  multimap["Firefox"]="$(join1 "$separator" /home/kamui/.cache/mozilla/firefox/*/cache2/entries)"
  # simulating: for f in echo /home/kamui/.cache/mozilla/firefox/*/cache2; do echo $f; mkdir -p "$f"/entries/{a..z}; done
  multimap["Teams"]="$(join1 "$separator" /home/kamui/.config/Microsoft/Microsoft\ Teams/{Cache,Code\ Cache,Service\ Worker/CacheStorage})"

  for key in "${!multimap[@]}"; do
    echo -e "\n$key"
    IFS="$separator" read -ra locations <<< "${multimap[$key]}"
    for location in "${locations[@]}"; do
#      echo "$location"
      __cleanup-dir "$location"
    done
  done

  #echo
  #echo "Firefox "
      #find /home/kamui/.mozilla/firefox/*/storage/default -path "*/morgue/*" -type d -exec rm -r {} + # delete ocasionally
# /home/kamui/.mozilla/firefox/ntrc3s4e.default/storage/default/https+++studio.youtube.com
  #echo -ne ".mozilla/firefox/ntrc3s4e.default/storage/default/https+++studio.youtube.com\t" && [ -d /home/kamui/.mozilla/firefox/ntrc3s4e.default/storage/default/https+++studio.youtube.com ] && rm -vr /home/kamui/.mozilla/firefox/ntrc3s4e.default/storage/default/https+++studio.youtube.com | wc -l || echo "Empty"

      #echo -ne "datareporting\t"; find ~kamui/.mozilla/firefox/*/ -path "*/datareporting/archived/*" -type d -exec rm -vr {} + | wc -l || echo "Empty"
      # this above can be tested with
          # mkdir ~kamui/.mozilla/firefox/icpoa0ej.ForTesting/datareporting/archived/test_dir$(date +%Y-%m-%d_%H-%M-%S)
          # ls ~kamui/.mozilla/firefox/icpoa0ej.ForTesting/datareporting/archived/
          # src && cleanup
          # ls ~kamui/.mozilla/firefox/icpoa0ej.ForTesting/datareporting/archived/

  # enabled if necessary
  #__cleanup-dir /home/kamui/.cache/sessions/
  #__cleanup-dir /home/kamui/.cache/mesa_shader_cache
  #__cleanup-dir /home/kamui/.cache/thumbnails/
  #__cleanup-dir /var/cache/fontconfig
}



err() { # set a return code and echo a message before returning from a function
    # usage: $FUNCNAME <return code> <message...>...
    # Function.
    # Parameter 1 is the return code.
    # Parameter 2 is the text to display on failure.

    RET_CODE=${1}

    if [ "$#" -ge "1" ];
    then
        shift
        echo "ERROR # ${RET_CODE} : $@" >&2
    else 
        echo "usage: $FUNCNAME <return code> <message...>..." >&2 # note that all arguments after the return value get turned into the printed message
    fi

        return ${RET_CODE}
    return ${RET_CODE}
}

dtd() { # date time <program> date
    date
    time "$@"
    RET_VAL=$?
    date
    return $RET_VAL
}

hostfiles() { # python -m http.server on a folder
    #echo "usage: $FUNCNAME [DIR=/] [PORT=8080]"
    echo "BE AWARE OF FORWARDED PORTS!!!"
    echo "Public IP is $(curl -s ifconfig.me)"
    echo "LAN IP is $(ifconfig | grep -A1 -E "^enp.*:" | tail -n 1 | awk '{print $2}')"
    echo "WiFi IP is $(ifconfig | grep -A1 -E "^wlp.*:" | tail -n 1 | awk '{print $2}')"
#    (cd /; python3 -m http.server 8080)
    

    echo "Default gateways:"
    ip route | grep default
    echo "Location is $(readlink -f ${1:-/})"
    echo "http://localhost:${2:-8080}/"
    echo "http://$(ifconfig | grep -A1 -E "^enp.*:" | tail -n 1 | awk '{print $2}'):${2:-8080}/"
    echo "http://$(ifconfig | grep -A1 -E "^wlp.*:" | tail -n 1 | awk '{print $2}'):${2:-8080}/"

    cd ${1:-/}; python3 -m http.server ${2:-8080}

#    PREV_DIR="$PWD"
#    trap 'cd "$PREV_DIR"; exit' SIGINT
#    cd /
#    python3 -m http.server ${2:-8080}
}


perm_to_script() { # chmod u+rx on a file/dir
    # usage: $FUNCNAME FILE|DIR
    # descr: gives to user read and execute permissions for a given file
    #   or to all .sh files in a given folder
    # ex:
    # $FUNCNAME /tmp
    # $FUNCNAME a.txt

    _LOC="${1}"
    [ -d "$1" ] && _LOC="${1%/}/*.sh"
    chmod u+rx $_LOC && [ -d "$1" ] && echo "All .sh files in this directory where given user read and user execute permissions."
    # testing: LOC=/tmp; chmod u-x $LOC/*.sh; clear; ls $LOC/*.sh; src > /dev/null && echo Sourced ~/.bashrc; perm_to_script $LOC; ls $LOC/*.sh;
}


# used to open programs like text editors in subshells and not have
# the output printed in the terminal
sp() { # spawn a program in a subshell in the background
    [[ $# -eq 0 ]] && { echo "Please provide a program to open (ex:
    mousepad a.txt)"; false; return; }
    WHERE_TO_SPAWN=$(pwd)
    WHAT_TO_DO="$@"
    #COMMAND_NAME="$1"
    #shift
    #OTHER_ARGS="$@"
    #( cd "$WHERE_TO_SPAWN"; pwd; "$COMMAND_NAME" "$OTHER_ARGS" &)
    ($WHAT_TO_DO &)
    # if I used the variable in double quotes, it would treat it as a
    # single command (aka including the arugments) and it would fail
}


sp2() { # spawn a program in a subshell in the background, V2
    if [ $# -eq 0 ]; then err 1 "Please provide a program to open (ex: mousepad a.txt"; return; fi

    local command=$1
    shift
    ($command "$@" &)

}


#######################################
# Provide information about user-defined functions
# Globals:
#   none
# Arguments:
#   name of an user-defiend function
# Outputs:
#   Writes the information written in ~/.functions about the function to STDOUT
# Returns:
#   0, on success - the function exists
#   1, invalid usage
#   2, function doesn't exist
#######################################
how() { # Provide information about user-defined functions
    # arguments parsing
    if [ $# -ne 1 ]; then err 1 "usage: $FUNCNAME <function name>"; return; fi

    # check if functions is defined
    if ! grep -q -E "^$1\(\) {" ~/.functions; then err 2 "$1() is not defined"; return; fi


    \grep -Pzo "(#{39}\n)(#.*\n)*"$1"\(\)" ~/.functions # inspired from: https://stackoverflow.com/a/7167115/17299754

    # method 2: find the line number of the function name then go upwards to the second 39 #'s

}

    ### Code Generating ### {{{
    
    ffor() {
        # usage: $FUNCNAME <dir/other iterable thing>
        cat <<EOF
for file in "$1";
do
    # start writing below
    
done

EOF
    }


    # }}}

# }}}



    ### VISUAL ### {{{


# change xfce terminal background darkness
terminal_darkness() { # change the xfce terminal's opacity
    [ $# -eq 0 ] && grep "BackgroundDarkness=" ~/.config/xfce4/terminal/terminalrc && return
    sed -Ei "s@(BackgroundDarkness=).*@\10,$1@" ~/.config/xfce4/terminal/terminalrc
}

# set the xfce tab title to pwd
title() { # set the xfce title to pwd or to a given string
    [ $# -eq 0 ] && TITLE="$PWD"
    [ $# -gt 0 ] && TITLE="$@"

    TITLE="${TITLE/\/home\/kamui\//\~/}" # replace /home/kamui/ with ~/ literal
    TITLE="${TITLE/\/mnt\/e\/Scratch/Scratch}"
    TITLE="${TITLE/\/mnt\/e/\/e}"
    TITLE="${TITLE/\/e\/Scratch/Scratch}"
    TITLE="${TITLE/\/e\/UBB_IE_2020-2023/UBBIE2020-2023}"
    TITLE="${TITLE/\/home\/kamui/\~}" # replace /home/kamui with ~ literal
    # TODO: instead of /home/kamui use $HOME

    # linux mint change xfce terminal window title using the command line -> https://askubuntu.com/questions/636944/how-to-change-the-title-of-the-current-terminal-tab-using-only-the-command-line -> https://askubuntu.com/a/1037309/1547353
    local ORIG_PS1=$PS1
    local TITLE="\e]2;$TITLE\a"
    PS1="${ORIG_PS1}${TITLE}"
}

cd() { # wrapper for cd which also sets the terminal window/tab title
    builtin cd "$@" # found the solution @ https://askubuntu.com/questions/1238467/xfce-terminal-run-script-on-session-restore
#    xtitle --version &> /dev/null && title # TODO check if this causes text overlapping in terminal (see  title())
    #title &> /dev/null # TODO: why it doesn't work?
}


# }}}



    ### TESTING ### {{{

testtrap () { 
    trap 'echo I refuse to quit' SIGINT;
    while :; do
        echo running;
    done
}
# }}}

__gcfgu() {
    [ $# -ne 2 ] && echo "usage: $FUNCNAME <m/u> # (main/uni)" && return 1

    # https://www.google.com/search?q=bash+return+2+vlues+from+function -> https://unix.stackexchange.com/questions/408543/how-can-a-bash-function-return-multiple-values
    local -n __user=$2

    case $1 in
    m)
        __user["username"]="sandrinopatrulescu"
        __user["email"]="sandryno_sandryno@yahoo.com"
      ;;
    u)
        __user["username"]="Patrulescu-Ronald-Sandrino"
        __user["email"]="prie2985@scs.ubbcluj.ro"
      ;;
    esac

    # debug print
#    for key in "${!__user[@]}"
#    do
#      echo "${key}, ${__user[${key}]}"
#    done
}

gcfgu() { # git config user local
    local -A user
    __gcfgu "$1" user || return $?

    git config --local user.name "${user["username"]}"
    git config --local user.email "${user["email"]}"
}

gcfgup() { # git config user local print
    local -A user
    __gcfgu "$1" user || return $?
    echo "git config --local user.name ${user["username"]}"
    echo "git config --local user.email ${user["email"]}"
}



#region references
# [1]
#endregion


#region bash completion

grep -rl "argcomplete\.autocomplete" "$DOTS"/bin --include="*.py" | while read -r file; do eval "$(register-python-argcomplete3 "$file")"; done


#endregiion

# vim: set filetype=sh : " treat this file as a shell script


# Notes:
#   1. add comments inside the function, for easier portability
#   2. functions specifications:
#       1. specifications should have 39 starting and ending #'s followed immediately by newline character (if you change this, then make sure to update how() accordingly)
#       2. 
#   3. use returns codes in the range 64 - 113 (https://tldp.org/LDP/abs/html/exitcodes.html)
# 



### uncategorized

beep() {
    # usage: $FUNCNAME [<count>]
    [ $# -eq 0 ] && count="1" || count="$1"

    for a in $(seq "$count"); 
    do
        paplay /usr/share/sounds/Lite/stereo/phone-incoming-call.oga
    done
    # source: https://www.newbiescorner.com/2017/12/06/beep-command-alert-when-the-task-is-finished/ 
}

# [1] get named variabled (usage: get <VAR_NAME>)
getvar() {
    echo "${!1}"
}



# [1] add a new directory to the PATH variable
# Note: I use this inside the env file, it doesn't seem to be working
# in terminal
append-path() {
    [ -d $1 ] && ! grep -q $1 <<< "$PATH" && export PATH=$PATH:$1
}



# [1]
calc() {
    echo "$*" | bc -l 
}


# [1]
mk() {
    mkdir -p "$@" && cd "$@"
}

    ### COMPILE ###

qtbuild() {
    if [[ ! -f "main.cpp" ]]
    then
    cat > main.cpp << EOF
#include <QApplication>
#include <QWidget>

int main(int argc, char* argv[]) {
    QApplication app(argc, argv);
    QWidget mainWidget{};
    mainWidget.show();
    return QApplication::exec();
}
EOF
    fi

    qmake -project
    echo 'QT += widgets' >> *.pro
    qmake
    sed -i -E 's@^(TARGET[ ]+=.+)@\1.out@' Makefile
    make && ./*.out
}


# edit c file in vi
vc() {
    vi "$1".c
}


## compile c file
#ccc()  {
#    # Note: output path:
#    #       - can be replaced with the argument "-o <output path>"
#    #       - should provide the name of the resulting file (extension included, if wanted) or the path to <name>.out
#    #       - example:
#    #           ccc -o out/main.out
#    #               or 
#    #           ccc -o main.elf
#    #               or
#    #           ccc -o /tmp/main.out
#    #               or
#    #           ccc -o ../dir1/dir2/<...>/dirn/main.elf
#    #               or
#    #           ccc -o ./out/main.elf
#
#
#    # set default compile-time arguments
#    COMPILE_ARGS="-Wall -pedantic -g"
#    unset OUTPUT_PATH    
#
#    # parse the provided arguments for compiler arguments (they start with a "-" (dash))
#    while [[ "$1" = -* ]]; do
#        [[ "$1" = -o ]] && { # replaces -o <name>.out with a custom path
#            shift
#            OUTPUT_PATH="$1"
#            shift
#            continue
#        }
#        COMPILE_ARGS="$COMPILE_ARGS $1"
#        shift
#    done
#
#    # make sure a filename is provided
#    [[ $# -lt 1 ]] && { echo "usage: $FUNCNAME [-<gcc arg>...] <name of c source WITHOUT extension> [<runtime arg>...]"; false; return; } 
#
#    # final set for the output path
#    FILENAME="$1"
#    [ -z $OUTPUT_PATH ] && OUTPUT_PATH="${FILENAME}.out" # set default output option -o is not given
#    [ -d "$OUTPUT_PATH" ] && { [[ "$OUTPUT_PATH" =~ /$ ]] && OUTPUT_PATH="${OUTPUT_PATH}${FILENAME}.out" || OUTPUT_PATH="${OUTPUT_PATH}/${FILENAME}.out"; }  # set default output file for directory given to -o option
#
#
#    # generate default c source file if none exists
#    [[ ! -f "${FILENAME}.c" ]] && 
#cat << end_str >> "${FILENAME}.c"
##include <stdio.h>
#
#int main(int argc, char **argv) {
#    
#
#    return 0;
#}
#end_str
#
#    # make a backup of the output file
#    [[ -f "${OUTPUT_PATH}" ]] && cp "${OUTPUT_PATH}" "${OUTPUT_PATH}".old
#
#    # print the compiler arguments
#    echo "\$COMPILE_ARGS=$COMPILE_ARGS -o ${OUTPUT_PATH}"
#
#    # compile the file
#    gcc $COMPILE_ARGS -o "${OUTPUT_PATH}" "${FILENAME}.c" || return $?
#
#    # run the program
#    shift # get rid of the filename in the function arguments
#    echo "--> Compilation done, now starting ${OUTPUT_PATH} <--" # print a message to know where program run starts
#    # if OUTPUT_PATH is not a path (by path, i mean: contains at least 1 '/' (forward slash)), prepend './' to it in order to run it
#    grep -q "/" <<< "$OUTPUT_PATH" && "$OUTPUT_PATH" $@ || ./"${OUTPUT_PATH}" $@
#    
#}
#

# added at 16.11.2021 22;49
# compile java file or create
jr() {
    [ $# -lt 1 ] && { echo "Please proide just the name of the .java file and the program args"; false; return; }
    JAVA_FILE_NAME="$1"
    FULL_NAME="${1}".java
    [ ! -f "${FULL_NAME}" ] &&
cat << end_str >> "${FULL_NAME}"

public class ${JAVA_FILE_NAME} {
    public static void main(String[] args) {
        
    }
}

end_str
    javac -Xlint:all "${FULL_NAME}"
    [ $? -eq 0 ] && { shift; echo "--> Compilation done, now starting ${JAVA_FILE_NAME}.class <--"; java "${JAVA_FILE_NAME}" $@; }

    # javafxc -d out/production/A7/ $(find src/ -name "*.java") &&
    # javafx -classpath out/production/A7/ view.Main
}

# 39 hash characters below
#######################################
# Compile and run JavaFX programs
#
# Globals:
#   JAVA_HOME
#   ?
#
# Arguments 1:
#   optional: -d Directory to place the class files, a path
#   Directory where .java files are located, an EXISTENT path
#   Starter class's full name, ex: [package1.][package2.]...[packageN.]MyClass
#   optional - Arguments for the JavaFX program
#   
# Arugments 2:
#   optional: -d Directory to place the class files, a path
#   Source file, path to an EXISTENT .java file
#   optional - Arguments for the JavaFX program
# 
# Outputs:
#  -> the output of the JavaFX program
#    
# Returns:
#   0, on success
#   64, JAVAFX_ARGS is unset
#   65, Source file/directory not found
#   66, Source file doesn't end in .java
# Purpose:
#   Replace javafxc -d out/production/A7/ \ 
#   $(find src/ -name "*.java") && javafx \
#   -classpath out/production/A7 view.Main
#   with 
#   jfxr out/production/A7 src/ view.Main
#
#######################################
jfxr() {

    # usage:
    local usage
    usage="\nusage:"
    usage+="\n$FUNCNAME [-d <DIR_FOR_CLASS_FILES>] <DIR_OF_SOURCE_FILES> <STARTER_CLASS_FULLNAME>"
    usage+="\n$FUNCNAME [-d <DIR_FOR_CLASS_FILE>] <SOURCE_FILE>"
    usage=$(echo -e $usage)

    # echo -e "$USAGE" # without quotes, it would convert the whitespaces into a single one, since it would be giving different arguments to echo
     
    # test if JAVAFX_ARGS is set
    if [ -z ${JAVAFX_ARGS+x} ]; then err 64 "JAVAFX_ARGS is unset$usage"; return; fi # check if a variable is set https://stackoverflow.com/a/13864829/17299754 
    
    local compile_args
    local run_args
    local starter_name

    # arguments parsing
    
    # test if output directory option is given
    if [ "$1" = "-d" ];
    then
        # set the output directory / classpath
        compile_args+=" -d $2"
        run_args+=" -classpath $2"

        shift 2 # move to next arugments
    fi

    # source file vs source directory
    # if it is a file
    if [ -f "$1" ];
    then
        # make sure it  ends in .java
        if [[ ! "$1" = *.java ]]; then err 66 "Source file: $1 doesn't end in .java$usage"; return; fi
        compile_args+=" $1"
        run_args+=" $1"
        starter_name=$(basename $1)
        shift; # move to next arguments
    elif [ -d "$1" ];
    then
        compile_args+=" $(find $1 -name "*.java")"
        run_args+=" $2" 
        starter_name=$2
        shift 2 # move to next arguments
    else
        err 65 "Source file/directory: $1 not found$usage"; return
    fi
    


    # compile
    #echo compile_args=$compile_args
    $JAVA_HOME/bin/javac $JAVAFX_ARGS $compile_args || return $? # compile successfully or return the error code of javac 

    echo "--> Compilation done, now starting ${starter_name/.java/} <--"
    # run
    #echo run_args=$run_args
    $JAVA_HOME/bin/java $JAVAFX_ARGS $run_args "$@"  


}


runc() {
# used for creating C programs to use with THREADS
if test $# -eq 0
then
    echo -e "ERROR: Must provide at least a name to the C program"
    false; return
else
    #if cat test.c | grep -Eqc "int main()"; then echo "found main"; else echo "not found"; fi
    if [ ! -f "$1.c" ]
    then
        echo '#include <stdio.h>' > "$1.c"
	    echo "" >> "$1.c"
	    echo "" >> "$1.c"
	    echo 'int main(int argc, char *argv[]) {' >> "$1.c"
	    echo '    printf("Hello, world!\n");' >> "$1.c"
	    echo "" >> "$1.c"
	    echo "    return 0;" >> "$1.c"
	    echo "}" >> "$1.c"
	    echo "" >> "$1.c"
    fi
    gcc -Wall -pedantic -g "$1.c" -o "$1.out" -pthread 
    NAME="$1"
    shift
    #echo "$@"
    ./"$NAME.out" $@ 
fi

}


    ### FS Management ###


# make file backups with timestamp inside the name

# be careful not to include the tralining / (slash) for directories
#   unless you want to copy inside the given directory
backup() {
    [ $# -lt 1 ] && { echo "Please provide at least 1 file name/path"; false; return; }
        
    # %/ used to avoid creating an additional directory
    # see rsync manual usage nr 4
    [ $# -eq 1 ] && { rsync -avP "$1" "${1%/}$(fdate)"; return; } 

    [ $# -gt 1 ] && {
        while [ $# -ne 0 ]; do
            rsync -avP "$1" "$1$(fdate)"
            shift
        done
        return

    }
}


# abandoned
backup2() {
    [ $# -lt 2 ] && { echo "usage: $FUNCNAME CASE SRC... [DEST]"; echo "CASE=1..4"; false; return; }

    # case 1: SRC DEST
    [ "$1" -eq 1 ] && rsync -avP "$2" "$3$(fdate)"

    # case 2: SRC
    [ "$1" -eq 2 ] && rsync -avP "$1" "$(basename "$1")$(fdate)"

    # case 3: SRC... DEST
    [ "$1" -eq 3 ] && rsync -avP 

    # case 4: SRC...
    [ "$1" -eq 4 ] && rsync -avP 

    [ "$1" -lt 1 ] || [ "$1" -gt 4 ] && echo "CASE must be in range 1..4" && false
}



big() {
    # usage: big
    #   or
    #  big <dir_followed_by_slash>
    #
    # !!! add / (slash) after directory
    du -sch ${1}{.[^.],}* | sort -h
}


sbig() {
    # usage: same as for big()
    sudo du -sch ${1}{.[^.],}* | sort -h
}

# example:
#   ./changeName.sh foo bar
#   results in:
#       foo.class -> bar.class
#       foo.java -> bar.java
changeName() {
       
    [ $# -eq 2 ] || { echo "usage: $FUNCNAME <path/to/file/with/out/extension> <new/name/without/extension>"; false; return; }
    
    for FILE in ${1}.*; do
        [ -e "$FILE" ] || continue
    
        EXT=$(echo $FILE | awk -F. '{print $2}')
        echo "${FILE%.*}.$EXT -> ${2}.$EXT" 
        #echo "${FILE} -> ${2}.$EXT" 
                                                                                    
        mv -- "$FILE" "${2}.$EXT"
    done
}


findSkipDirs() {
    USAGE="usage: findSkipDirs -p|n <file_with_dirs|dirs...>"

    # check and set the mode
    unset MODE
    [ "$1" = "-p" ] && MODE="-path"
    [ "$1" = "-n" ] && MODE="-name"
    [ -z "$MODE" ] && { echo $USAGE; return 1; }

    # set the mode for receving the directory names/paths
    [ -f "$2" ] && DIRS=$(cat "$2") || { shift; DIRS=$@; }


    COUNT=0
    echo -n " -type d \( "
    for DIR in $DIRS; do
        [ $COUNT -eq 0 ] || echo -n "-o "
        echo -n $MODE "${DIR%/} "  
        COUNT=$((COUNT+1))
    done
    echo "\) -prune -o"
    echo "!!! paste it while the cursor is on the first space after the search location"
    echo
    echo "example 1: "
    echo 'sudo find / -type d -type d \( -name Google -o -name timeshift \) -prune -o -iname "*jetbrains*" -print'
    echo "example 2: "
    echo '_ find / -type d \( -path /mnt -o -path /home/timeshift -o -path /proc \) -prune -o -iname "*cxoffice*" | tee --append find-output_$(fdate).txt'
    #sudo find . -type d \( -path ./.cache/Google -o -path ./.mozilla/firefox \) -prune -o -iname "*jetbrains*" -print

    # Notes: name + -print doesn't work
    # testable with
    # rm /tmp/find-w-print.txt; date; time sudo find / -type d -type d \( -name Google -o -name timeshift \) -prune -o -iname "*jetbrains*" -print | tee --append /tmp/find-w-print.txt; date
    # rm /tmp/find-wo-print.txt; date; time sudo find / -type d -type d \( -name Google -o -name timeshift \) -prune -o -iname "*jetbrains*" | tee --append /tmp/find-wo-print.txt; date
    # diff /tmp/find-w-print.txt /tmp/find-wo-print.txt
}


sprune() {
    echo -n "find . -iname \"*\""
    for ARG in $DIR_LINES
    do
        # [ -d "$ARG" ] && # test whether it's a directory
        echo -n " -path \"$ARG\" -prune" # note the space at the end of the string
    done
    echo
}


tot() {
# aka to trash
    # usage: $FUNCNAME <file_to_trash> [-l <location>] <REASON>

    # arguments parsing
    local file_to_trash="$1"
    local location
    if [ ! -e "$file_to_trash" ]; then err 1 "file_to_trash=$file_to_trash does not exist"; return; fi

    shift # now $@ = [-l <location>] reason

    # handle the -l parameter
    if [ "$1" = "-l" ];
    then
        location="$2"
        if ! readlink -f "${location}" | grep -q "^$TRASH"; then err 1 "location=${location} is not TRASH"; return; fi # more info on negation and pipelines at man bash -> SHELL GRAMMAR -> Pipelines
        if [ ! -d "${location}" ]; then err 1 "location=${location} is not a valid directory inside TRASH"; return; fi
        shift 2 # now $@ = reason
    fi 
    # set location to env TRASH if not set, assuming env TRASH is set
    : ${location=$TRASH} # source: https://stackoverflow.com/a/12405621/17299754

    # now $@ = reason
    if [ ! $# -ge "1" ]; then err 1 "REASON is not given"; return; fi  # check that a reason is given
    
    local full_path_to_file_to_trash="$(readlink -f "$file_to_trash")"
    mv -v "$full_path_to_file_to_trash" "$location" && echo "$(fdate)|$full_path_to_file_to_trash|$@" >> $TRASH/0.info

}


#######################################
# tail trash: tt or tt <nr of lines> 
#######################################
tt() 
{ 
    if [ $# -ne 1 ];
    then
        tail "$TRASH"/0.info;
    else
        tail -n "$1" "$TRASH"/0.info;
    fi
}


    ### NAVIGATION ###

getpwd() {
    (cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
}




    ### SYSTEM ANALYSIS ###


# memory watcher
mw() {
    while :; do date; free -h; sleep 1; clear; done
}


# deprecated: $1 = foo/a/a.txt must be changed to ./foo/a/.txt
sln() {
    # sln OLD NEW
    # sln OLD # it is done in the current folder
    # TODO test if OLD exists and that NEW doesn't exists
    ERR_MSG="$(cat <<'EOS'
usage: sln OLD NEW\n
or\n
usage: sln OLD
EOS
)"
    [ $# -ge 1 -a $# -le 2 ] || { echo "$ERR_MSG"; return 1; }

    [ -e "$1" ] || { echo "sln() fail: $1 is NOT file"; return 1; }
    OLD_FILE="$1"
    NEW_LOC="."

    [ $# -eq 2 ] && [ -d "$2" ] || { echo "sln() faild: $2 is NOT a directory"; return 1; }
    NEW_LOC="$2"
    FILE_NAME="$(basename "$OLD_FILE")"
    [ -e "$NEW_LOC/$FILE_NAME" ] && { echo "sln() fail: $NEW_LOC/$FILE_NAME already exists"; return 1; }
    ln -s "$OLD_FILE" "$NEW_LOC"  && echo "$NEW_LOC -> $OLD_FILE"
}


    ### UTILS ###

#calculator awk
cawk() {
    # Note: * has to be escaped
    echo | awk "{print $*}"
}


cleanup() {
    echo "Chrome "
    #rm -r /home/kamui/.cache/google-chrome/Default/Cache/* /home/kamui/.cache/google-chrome/Default/Code\ Cache/js/*
    echo -ne "Default/Service Worker/CacheStorage\t" && [ -d /e/LL5.6/home/kamui/.config/google-chrome/Default/Service\ Worker/CacheStorage ] && rm -r /e/LL5.6/home/kamui/.config/google-chrome/Default/Service\ Worker/CacheStorage | wc -l || echo "Empty"

    echo
    echo "Firefox " 
        #find /home/kamui/.mozilla/firefox/*/storage/default -path "*/morgue/*" -type d -exec rm -r {} + # delete ocasionally

        find /home/kamui/.mozilla/firefox/*/ -path "*/datareporting/archived/*" -type d -exec rm -r {} +
        # this above can be tested with
            # mkdir ~kamui/.mozilla/firefox/icpoa0ej.ForTesting/datareporting/archived/test_dir$(fdate)
            # ls ~kamui/.mozilla/firefox/icpoa0ej.ForTesting/datareporting/archived/
            # src && cleanup
            # ls ~kamui/.mozilla/firefox/icpoa0ej.ForTesting/datareporting/archived/

        for PROFILE_DIR in $(find /home/kamui/.cache/mozilla/firefox/ -mindepth 1 -maxdepth 1 -type d); do 
            echo -ne "$(basename "$PROFILE_DIR")\t" && [ -d "$PROFILE_DIR/cache2" ] && rm -r "$PROFILE_DIR/cache2" | wc -l || echo "Empty"
        done
        #[ -d /home/kamui/.cache/mozilla/firefox/*/cache2 ] && rm -r /home/kamui/.cache/mozilla/firefox/*/cache2 | wc -l || echo -e "\tEmpty" # OLD - used with 1 single profile

    echo
    echo "Teams "
    echo -ne "Cache\t" && [ -d '/home/kamui/.config/Microsoft/Microsoft Teams/Cache'/ ] && rm -r '/home/kamui/.config/Microsoft/Microsoft Teams/Cache'/ | wc -l || echo "Empty"
    echo -ne "Code Cache\t" && [ -d '/home/kamui/.config/Microsoft/Microsoft Teams/Code Cache'/ ] && rm -r '/home/kamui/.config/Microsoft/Microsoft Teams/Code Cache'/ | wc -l || echo "Empty"
}



err() {
    # usage: $FUNCNAME <return code> <message...>...
    # Function.
    # Parameter 1 is the return code.
    # Parameter 2 is the text to display on failure.
    if [ "$#" -ge "1" ];
    then
        RET_CODE=${1}
        shift
        echo "ERROR # ${RET_CODE} : $@" >&2
        return ${RET_CODE}
    else 
        echo "usage: $FUNCNAME <return code> <message...>..." >&2 # note that all arguments after the return value get turned into the printed message
    fi
}

# date time date
dtd() {
    date
    time "$@"
    RET_VAL=$?
    date
    return $RET_VAL
}

hostfiles() {
    #echo "usage: $FUNCNAME [PORT=8080]"
    echo "IP is $(ifconfig | grep -A1 -E "^wlp3s0:" | tail -n 1 | awk '{print $2}')"
#    (cd /; python3 -m http.server 8080)
    
    cd /; python3 -m http.server ${1:-8080}

#    PREV_DIR="$PWD"
#    trap 'cd "$PREV_DIR"; exit' SIGINT
#    cd /
#    python3 -m http.server ${1:-8080}
}


perm_to_script() {
    # usage: $FUNCNAME FILE|DIR
    # descr: gives to user read and execute permissions for a given file
    #   or to all .sh files in a given folder
    # ex:
    # $FUNCNAME /tmp
    # $FUNCNAME a.txt

    _LOC="${1}"
    [ -d "$1" ] && _LOC="${1%/}/*.sh"
    chmod u+rx $_LOC && [ -d "$1" ] && echo "All .sh files in this directory where given user read and user execute permissions."
    # testing: LOC=/tmp; chmod u-x $LOC/*.sh; clear; ls $LOC/*.sh; src > /dev/null && echo Sourced ~/.bashrc; perm_to_script $LOC; ls $LOC/*.sh;
}


# used to open programs like text editors in subshells and not have
# the output printed in the terminal
sp() {
    [[ $# -eq 0 ]] && { echo "Please provide a program to open (ex:
    mousepad a.txt)"; false; return; }
    WHERE_TO_SPAWN=$(pwd)
    WHAT_TO_DO="$@"
    #COMMAND_NAME="$1"
    #shift
    #OTHER_ARGS="$@"
    #( cd "$WHERE_TO_SPAWN"; pwd; "$COMMAND_NAME" "$OTHER_ARGS" &)
    ($WHAT_TO_DO &)
    # if I used the variable in double quotes, it would treat it as a
    # single command (aka including the arugments) and it would fail
}


sp2() {
    if [ $# -eq 0 ]; then err 1 "Please provide a program to open (ex: mousepad a.txt"; return; fi

    local command=$1
    shift
    ( $command "$@" &)

}


#######################################
# Provide information about user-defined functions
# Globals:
#   none
# Arguments:
#   name of an user-defiend function
# Outputs:
#   Writes the information written in ~/.functions about the function to STDOUT
# Returns:
#   0, on success - the function exists
#   1, invalid usage
#   2, function doesn't exist
#######################################
how() {
    # arguments parsing
    if [ $# -ne 1 ]; then err 1 "usage: $FUNCNAME <function name>"; return; fi

    # check if functions is defined
    if ! grep -q "^$1\(\) {" ~/.functions; then err 2 "$1() is not defined"; return; fi


    \grep -Pzo "(#{39}\n)(#.*\n)*"$1"\(\)" ~/.functions # inspired from: https://stackoverflow.com/a/7167115/17299754

    # method 2: find the line number of the function name then go upwards to the second 39 #'s

}

    ### VISUAL ###


# change xfce terminal background darkness
terminal_darkness() {
    [ $# -eq 0 ] && grep "BackgroundDarkness=" ~/.config/xfce4/terminal/terminalrc && return
    sed -Ei "s@(BackgroundDarkness=).*@\10,$1@" ~/.config/xfce4/terminal/terminalrc
}

# set the xfce tab title to pwd
title() {
    xtitle --version &> /dev/null || { echo "$FUNCNAME: ERROR - xtitle is not installed"; return 1; }

    [ $# -eq 0 ] && {
        TITLE="$PWD"       
        
    }
    [ $# -eq 1 ] && {
        TITLE="$1"
    }
    [ $# -gt 1 ] && echo "usage: $FUNCNAME [<title>]" && return 1
    TITLE="${TITLE/\/home\/kamui\//\~/}" # replace /home/kamui/ with ~/ literal
    TITLE="${TITLE/\/mnt\/e\/Scratch/Scratch}"
    TITLE="${TITLE/\/mnt\/e/\/e}"
    TITLE="${TITLE/\/e\/Scratch/Scratch}"
    xtitle "${TITLE/\/home\/kamui/\~}" #&& echo title was set # replace /home/kamui with ~
}

cd() {
    builtin cd "$@" # found the solution @ https://askubuntu.com/questions/1238467/xfce-terminal-run-script-on-session-restore
    xtitle --version &> /dev/null && title
    #title &> /dev/null # TODO: why it doesn't work?
}


    ### TESTING ###

testtrap () { 
    trap 'echo I refuse to quit' SIGINT;
    while :; do
        echo running;
    done
}


# references
# [1]
